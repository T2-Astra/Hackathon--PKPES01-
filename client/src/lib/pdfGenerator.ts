import jsPDF from 'jspdf';

interface PDFOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
}

export const generateStudyNotesPDF = (content: string, options: PDFOptions = {}): void => {
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Set document properties
    pdf.setProperties({
      title: options.title || 'Study Notes',
      author: options.author || 'PolyLearnHub',
      subject: options.subject || 'AI Generated Study Notes',
      keywords: options.keywords || 'study, notes, education, AI',
      creator: 'PolyLearnHub AI Assistant'
    });

    // Set font
    pdf.setFont('helvetica', 'normal');
    
    // Add header
    pdf.setFontSize(20);
    pdf.setTextColor(40, 40, 40);
    pdf.text(options.title || 'Study Notes', 20, 30);
    
    // Add date
    pdf.setFontSize(10);
    pdf.setTextColor(100, 100, 100);
    pdf.text(`Generated on: ${new Date().toLocaleDateString()}`, 20, 40);
    pdf.text('Created by: PolyLearnHub AI Assistant', 20, 45);
    
    // Add separator line
    pdf.setDrawColor(200, 200, 200);
    pdf.line(20, 50, 190, 50);

    // Process content
    const cleanContent = content
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
      .replace(/\*(.*?)\*/g, '$1')     // Remove italic markdown
      .replace(/`(.*?)`/g, '$1')       // Remove inline code markdown
      .replace(/#{1,6}\s/g, '')        // Remove headers
      .replace(/^\s*[-*+]\s/gm, '• ') // Convert list items to bullets
      .replace(/^\s*\d+\.\s/gm, '')   // Remove numbered list numbers
      .trim();

    // Split content into lines and add to PDF
    pdf.setFontSize(11);
    pdf.setTextColor(60, 60, 60);
    
    const pageWidth = 190; // A4 width minus margins
    const lineHeight = 6;
    let yPosition = 60;
    const maxLinesPerPage = 40;
    let currentLine = 0;

    // Split content by paragraphs first
    const paragraphs = cleanContent.split(/\n\s*\n/);
    
    paragraphs.forEach((paragraph) => {
      if (!paragraph.trim()) return;
      
      // Check if we need a new page
      if (currentLine >= maxLinesPerPage) {
        pdf.addPage();
        yPosition = 20;
        currentLine = 0;
      }
      
      // Handle long paragraphs by splitting them
      const lines = pdf.splitTextToSize(paragraph.trim(), pageWidth);
      
      lines.forEach((line: string) => {
        if (currentLine >= maxLinesPerPage) {
          pdf.addPage();
          yPosition = 20;
          currentLine = 0;
        }
        
        pdf.text(line, 20, yPosition);
        yPosition += lineHeight;
        currentLine++;
      });
      
      // Add extra space after paragraph
      yPosition += 3;
      currentLine += 0.5;
    });

    // Add footer to all pages
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.setTextColor(150, 150, 150);
      pdf.text(`Page ${i} of ${totalPages}`, 20, 285);
      pdf.text('Generated by PolyLearnHub AI', 150, 285);
    }

    // Generate filename
    const timestamp = new Date().toISOString().slice(0, 10);
    const filename = `${(options.title || 'Study_Notes').replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}.pdf`;

    // Save the PDF
    pdf.save(filename);
    
    console.log('✅ PDF generated successfully:', filename);
  } catch (error) {
    console.error('❌ Error generating PDF:', error);
    throw new Error('Failed to generate PDF');
  }
};

// Comprehensive markdown cleaner that preserves structure
const cleanMarkdownContent = (content: string): string => {
  return content
    // Remove metadata lines
    .replace(/^Generated:.*$/gm, '')
    .replace(/^Source:.*$/gm, '')
    .replace(/^\d+\s*\/\s*\d+$/gm, '')
    
    // Clean LaTeX and math formulas
    .replace(/\\\[/g, '')
    .replace(/\\\]/g, '')
    .replace(/\\\(/g, '')
    .replace(/\\\)/g, '')
    .replace(/\\text\{([^}]+)\}/g, '$1')
    .replace(/\\beta_(\d+)/g, 'β$1')
    .replace(/\\sum/g, 'Σ')
    .replace(/\\times/g, '×')
    .replace(/\\log/g, 'log')
    .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)')
    .replace(/\\hat\{([^}]+)\}/g, '$1̂')
    .replace(/\{([^}]+)\}/g, '$1')
    .replace(/\\\\/g, '')
    
    // Remove ALL markdown formatting but preserve structure
    .replace(/\*\*\*(.*?)\*\*\*/g, '$1')  // Bold italic
    .replace(/\*\*(.*?)\*\*/g, '$1')      // Bold
    .replace(/\*(.*?)\*/g, '$1')          // Italic
    .replace(/__(.*?)__/g, '$1')          // Bold underscore
    .replace(/_(.*?)_/g, '$1')            // Italic underscore
    .replace(/`{3}[\s\S]*?`{3}/g, '')     // Code blocks
    .replace(/`(.*?)`/g, '$1')            // Inline code
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Links
    
    // Clean up brackets and special characters
    .replace(/\[/g, '')
    .replace(/\]/g, '')
    .replace(/\\_/g, '_')
    .replace(/\\#/g, '#')
    .replace(/\\\*/g, '*')
    
    // Preserve paragraph structure - DON'T collapse all whitespace
    .replace(/\n{3,}/g, '\n\n')  // Normalize multiple line breaks to double
    .trim();
};

export const generateFormattedStudyNotesPDF = (content: string, title: string = 'Study Notes'): { blob: Blob; filename: string } => {
  try {
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Extract better title from content
    let pdfTitle = title;
    const cleanContent = cleanMarkdownContent(content);
    
    // Try to extract title from various patterns
    const titlePatterns = [
      /^#{1,3}\s*(.+?)$/m,
      /Study Notes on\s+(.+?)(?:\n|$)/i,
      /Comprehensive.*?Notes.*?on\s+(.+?)(?:\n|$)/i,
      /^(.+?)\s*Study Notes/i
    ];
    
    for (const pattern of titlePatterns) {
      const match = cleanContent.match(pattern);
      if (match && match[1]) {
        pdfTitle = match[1].trim();
        break;
      }
    }

    // Clean up title for filename
    const cleanTitle = pdfTitle.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, ' ').trim();

    // Set document properties
    pdf.setProperties({
      title: pdfTitle,
      author: 'PolyLearnHub AI',
      subject: 'AI Generated Study Notes',
      creator: 'PolyLearnHub'
    });

    let yPosition = 25;
    const pageWidth = 170;
    const lineHeight = 6;
    const maxY = 275;

    // Title - ALL BLACK
    pdf.setFontSize(20);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(0, 0, 0); // Pure black
    const titleLines = pdf.splitTextToSize(pdfTitle, pageWidth);
    titleLines.forEach((line: string) => {
      pdf.text(line, 20, yPosition);
      yPosition += 9;
    });
    yPosition += 6;

    // Date and source - BLACK
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(0, 0, 0); // Pure black
    pdf.text(`Generated: ${new Date().toLocaleString()}`, 20, yPosition);
    yPosition += 4;
    pdf.text('Source: PolyLearnHub AI Assistant', 20, yPosition);
    yPosition += 10;

    // Separator - BLACK
    pdf.setDrawColor(0, 0, 0); // Pure black line
    pdf.setLineWidth(0.5);
    pdf.line(20, yPosition, 190, yPosition);
    yPosition += 10;

    // Process the cleaned content with proper paragraph handling
    const processedContent = cleanMarkdownContent(content);
    
    // Split into paragraphs first, then process each paragraph
    const paragraphs = processedContent.split(/\n\s*\n/);
    
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i].trim();
      
      if (!paragraph) continue;

      // Check if we need a new page
      if (yPosition > maxY - 20) {
        pdf.addPage();
        yPosition = 20;
      }

      // Detect content type and format accordingly
      if (paragraph.match(/^#{1,6}\s/) || paragraph.match(/^###?\s/)) {
        // Headers - ALL BLACK
        const headerText = paragraph.replace(/^#+\s*/, '');
        
        // Skip if same as main title
        if (headerText === pdfTitle) continue;
        
        yPosition += 6;
        pdf.setFont('helvetica', 'bold');
        pdf.setTextColor(0, 0, 0); // Pure black for all headers
        
        // Different sizes for different header levels
        if (paragraph.match(/^#{1,2}\s/)) {
          pdf.setFontSize(15);
        } else {
          pdf.setFontSize(13);
        }
        
        const headerLines = pdf.splitTextToSize(headerText, pageWidth);
        headerLines.forEach((headerLine: string) => {
          if (yPosition > maxY) {
            pdf.addPage();
            yPosition = 20;
          }
          pdf.text(headerLine, 20, yPosition);
          yPosition += 7;
        });
        yPosition += 4;
        
      } else if (paragraph.includes('- ') || paragraph.includes('• ')) {
        // Handle bullet point lists - Normal weight text with bold key terms
        const bulletItems = paragraph.split(/(?=^- |^• )/m);
        
        pdf.setFontSize(11);
        pdf.setTextColor(0, 0, 0);
        
        bulletItems.forEach((item) => {
          const cleanItem = item.replace(/^[-•]\s*/, '').trim();
          if (!cleanItem) return;
          
          // Check if item has a bold key term at the start (before colon or dash)
          const keyTermMatch = cleanItem.match(/^([^:–-]+)[:–-]\s*(.+)$/);
          
          if (keyTermMatch && keyTermMatch[1].length < 50) {
            // Has key term - render it bold, rest normal
            const keyTerm = keyTermMatch[1].trim();
            const description = keyTermMatch[2].trim();
            
            if (yPosition > maxY) {
              pdf.addPage();
              yPosition = 20;
            }
            
            // Bold key term
            pdf.setFont('helvetica', 'bold');
            const bullet = '• ';
            const keyText = `${bullet}${keyTerm}: `;
            const keyWidth = pdf.getTextWidth(keyText);
            pdf.text(keyText, 25, yPosition);
            
            // Normal description
            pdf.setFont('helvetica', 'normal');
            const descLines = pdf.splitTextToSize(description, pageWidth - 10 - keyWidth);
            pdf.text(descLines[0] || '', 25 + keyWidth, yPosition);
            yPosition += lineHeight;
            
            // Remaining lines of description
            for (let i = 1; i < descLines.length; i++) {
              if (yPosition > maxY) {
                pdf.addPage();
                yPosition = 20;
              }
              pdf.text(descLines[i], 30, yPosition);
              yPosition += lineHeight;
            }
          } else {
            // No key term - render all normal
            pdf.setFont('helvetica', 'normal');
            const wrappedText = pdf.splitTextToSize(`• ${cleanItem}`, pageWidth - 10);
            
            wrappedText.forEach((wrappedLine: string) => {
              if (yPosition > maxY) {
                pdf.addPage();
                yPosition = 20;
              }
              pdf.text(wrappedLine, 25, yPosition);
              yPosition += lineHeight;
            });
          }
          yPosition += 1;
        });
        yPosition += 3;
        
      } else if (paragraph.match(/^\d+\.\s/) || paragraph.includes('Example')) {
        // Numbered items and examples - BLACK
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(11);
        pdf.setTextColor(0, 0, 0); // Pure black
        
        const wrappedText = pdf.splitTextToSize(paragraph, pageWidth - 10);
        
        wrappedText.forEach((wrappedLine: string) => {
          if (yPosition > maxY) {
            pdf.addPage();
            yPosition = 20;
          }
          pdf.text(wrappedLine, 25, yPosition);
          yPosition += lineHeight;
        });
        yPosition += 4;
        
      } else if (paragraph.includes('=') || paragraph.includes('β') || paragraph.includes('Σ') || paragraph.includes('×') || paragraph.includes('MSE') || paragraph.includes('Accuracy')) {
        // Mathematical formulas - BLACK
        pdf.setFont('courier', 'normal');
        pdf.setFontSize(10);
        pdf.setTextColor(0, 0, 0); // Pure black
        
        yPosition += 2;
        const wrappedText = pdf.splitTextToSize(paragraph, pageWidth - 20);
        
        wrappedText.forEach((wrappedLine: string) => {
          if (yPosition > maxY) {
            pdf.addPage();
            yPosition = 20;
          }
          pdf.text(wrappedLine, 30, yPosition);
          yPosition += lineHeight;
        });
        yPosition += 4;
        
      } else {
        // Regular paragraph text - Normal weight with bold key terms if present
        pdf.setFontSize(11);
        pdf.setTextColor(0, 0, 0);
        
        // Check if paragraph starts with a key term (before colon or dash)
        const keyTermMatch = paragraph.match(/^([^:–-]+)[:–-]\s*([\s\S]+)$/);
        
        if (keyTermMatch && keyTermMatch[1].length < 60 && !keyTermMatch[1].includes('\n')) {
          // Has key term at start - render it bold, rest normal
          const keyTerm = keyTermMatch[1].trim();
          const description = keyTermMatch[2].trim();
          
          // Bold key term
          pdf.setFont('helvetica', 'bold');
          const keyText = `${keyTerm}: `;
          const keyWidth = pdf.getTextWidth(keyText);
          pdf.text(keyText, 20, yPosition);
          
          // Normal description
          pdf.setFont('helvetica', 'normal');
          const descLines = pdf.splitTextToSize(description, pageWidth - keyWidth);
          
          // First line continues on same line as key term
          if (descLines.length > 0) {
            pdf.text(descLines[0], 20 + keyWidth, yPosition);
            yPosition += lineHeight;
          }
          
          // Remaining lines
          for (let i = 1; i < descLines.length; i++) {
            if (yPosition > maxY) {
              pdf.addPage();
              yPosition = 20;
            }
            pdf.text(descLines[i], 20, yPosition);
            yPosition += lineHeight;
          }
        } else {
          // No key term - render all normal weight
          pdf.setFont('helvetica', 'normal');
          const wrappedText = pdf.splitTextToSize(paragraph, pageWidth);
          
          wrappedText.forEach((wrappedLine: string) => {
            if (yPosition > maxY) {
              pdf.addPage();
              yPosition = 20;
            }
            pdf.text(wrappedLine, 20, yPosition);
            yPosition += lineHeight;
          });
        }
        
        yPosition += 5; // Consistent spacing between paragraphs
      }
    }

    // Add page numbers - BLACK
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.setTextColor(0, 0, 0); // Pure black
      pdf.text(`${i} / ${totalPages}`, 185, 285);
    }

    // Generate filename using clean title
    const timestamp = new Date().toISOString().slice(0, 10);
    const filename = `${cleanTitle.replace(/\s+/g, '_')}_${timestamp}.pdf`;

    // Return PDF blob and filename instead of auto-downloading
    const pdfBlob = pdf.output('blob');
    
    return { blob: pdfBlob, filename };
  } catch (error) {
    console.error('❌ Error generating formatted PDF:', error);
    throw new Error('Failed to generate PDF');
  }
};

// Utility function to download a PDF blob
export const downloadPDF = (blob: Blob, filename: string): void => {
  try {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    console.log('✅ PDF downloaded successfully:', filename);
  } catch (error) {
    console.error('❌ Error downloading PDF:', error);
    throw new Error('Failed to download PDF');
  }
};
